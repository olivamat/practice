/* 
  Сеть фастфудов предлагает несколько видов гамбургеров. 
  Гамбургер может быть с одной из нескольких видов начинок (обязательно):
	- сыром (+15 денег, +20 калорий)
	- салатом (+20 денег, +5 калорий)
	- мясом (+35 денег, +15 калорий)
	
  Дополнительно, гамбургер можно: 
	- посыпать приправой (+10 денег, +0 калорий) 
	- полить соусом (+15 денег, +5 калорий)
  Типы начинок и размеры надо сделать константами. Никаких магических строк не должно быть.
  Напишите скрипт, расчитывающий стоимость и калорийность гамбургера. 
  Используте ООП подход, создайте класс Hamburger, константы, методы 
  для выбора опций и рассчета нужных величин. 
  Класс Hamburger, получает на вход информацию о гамбургере, а на выходе 
  дает информацию о каллориях и цене. Никакого взаимодействия с пользователем 
  и внешним миром класс делать не должен - все нужные данные ему передают явно
  в виде аргументов при создании экземпляра. 
  Почему? Потому что каждый должен заниматься своим делом, класс должен только 
  рассчитывать результирующий гамбургер, а вводом-выводом пусть занимается 
  внешний, относительно него, код. Такой класс унивесален: можно использовать его 
  выводя данные через console.log, а можно создать интерфейс с кнопками и полями ввода. 
  Именно в таком стиле необходимо писать код, тем самым достигая универсальности 
  и возможности повторного использования.
  Написанный класс должен соответствовать следующему jsDoc описанию функции-конструктора,
  но вам **НЕОБХОДИМО НАПИСАТЬ ИМЕННО ES6 CLASS**. То есть класс должен содержать указанные методы, 
  которые принимают и возвращают данные указанного типа:
*/

/**
* Класс, объекты которого описывают параметры гамбургера. 
* 
* @constructor
* @param size        Размер
* @param stuffing    Начинка
* @throws {HamburgerException}  При неправильном использовании (только в доп. задании)
*/
function Hamburger(size, stuffing) { ... } 

/* Размеры, виды начинок и добавок добавить как статические свойства класса */
Hamburger.SIZE_SMALL = ...
Hamburger.SIZE_LARGE = ...
Hamburger.STUFFING_CHEESE = ...
Hamburger.STUFFING_SALAD = ...
Hamburger.STUFFING_MEAT = ...
Hamburger.TOPPING_SPICE = ...
Hamburger.TOPPING_SAUCE = ...

/**
* Добавить topping к гамбургеру. Можно добавить несколько
* topping, при условии, что они разные.
* 
* @param topping  Тип добавки
* @throws {HamburgerException}	При неправильном использовании (только в доп. задании)
*/
Hamburger.prototype.addTopping = function (topping) { ... }

/**
 * Убрать topping, при условии, что она ранее была 
 * добавлена.
 * 
 * @param topping  Тип добавки
 * @throws {HamburgerException}  При неправильном использовании (только в доп. задании)
 */
Hamburger.prototype.removeTopping = function (topping) { ... }

/**
 * Получить список topping.
 *
 * @return {Array} Массив добавленных topping, содержит константы
 *                 Hamburger.TOPPING_*
 */
Hamburger.prototype.getToppings = function () { ... }

/**
 * Узнать размер гамбургера
 */
Hamburger.prototype.getSize = function () { ... }

/**
 * Узнать начинку гамбургера
 */
Hamburger.prototype.getStuffing = function () { ... }

/**
 * Узнать цену гамбургера
 * @return {Number} Цена в деньгах
 */
Hamburger.prototype.calculatePrice = function () { ... }

/**
 * Узнать калорийность
 * @return {Number} Калорийность в калориях
 */
Hamburger.prototype.calculateCalories = function () { ... }


/* 
  Переданную информацию о параметрах гамбургера 
  класс хранит внутри в своих полях. Вот как может 
  выглядеть использование этого класса:
*/

// маленький гамбургер с начинкой из сыра
const hamburger = new Hamburger(Hamburger.SIZE_SMALL, Hamburger.STUFFING_CHEESE);

// добавка из приправы
hamburger.addTopping(Hamburger.TOPPING_SPICE);

// спросим сколько там калорий
console.log("Calories: %f", hamburger.calculateCalories());

// сколько стоит
console.log("Price: %f", hamburger.calculatePrice());

// я тут передумал и решил добавить еще соус
hamburger.addTopping(Hamburger.TOPPING_SAUCE);

// А сколько теперь стоит? 
console.log("Price with sauce: %f", hamburger.calculatePrice());

// Проверить, большой ли гамбургер? 
console.log("Is hamburger large: %s", hamburger.getSize() === Hamburger.SIZE_LARGE); // -> false

// Убрать добавку
hamburger.removeTopping(Hamburger.TOPPING_SPICE);
console.log("Have %d toppings", hamburger.getToppings().length); // 1

/*
  Обратите внимание в коде выше на такие моменты:
    - класс не взаимодействует с внешним миром. Это не его дело, этим занимается другой код, 
    	а класс живет в изоляции от мира
	
    - обязательные параметры (размер и начинка) мы передаем через конструктор, 
    	чтобы нельзя было создать объект, не указав их
	
    - необязательные (добавка) добавляем через методы
    - имена методов начинаются с глагола и имеют вид «сделайЧтоТо»: calculateCalories(), addTopping()
    
    - типы начинок обозначены "константами" с понятными именами (на самом деле просто свойствами, 
      	написанным заглавными буквами, которые мы договорились считать "константами")
	
    - объект создается через конструктор - функцию, которая задает начальные значения полей. 
      	Имя конструктора пишется с большой буквы и обычно является существительным: new Hamburger(...)
	
    - "константы" вроде могут иметь значение, являющееся строкой или числом. От смены значения константы 
      ничего не должно меняться (то есть эти значения не должны где-то еще быть записаны). 
      
    - в свойствах объекта гамбургера логично хранить исходные данные (размер, тип начинки), 
      а не вычисленные из них (цена, число калорий и т.д.). Рассчитывать цену и калории логично 
      в тот момент, когда это потребуется, а не заранее.
	
  При решении задачи в ООП стиле, необходимо ответить на вопросы:	
    - какие есть сущности, для которых мы сделаем классы? (Гамбургер).
    - какие у них есть свойства (размер, начинка, добавки). Цена или калории не являются свойствами так 
      как они вычисляются из других свойств и хранить их не надо.
    - что мы хотим от них получить (какие у них должны быть методы). Например, сколько стоит гамбургер?
    - как сущности связаны? У нас одна сущность «Гамбургер» и она ни с чем не связана.
*/

/*
  ***ЗАДАНИЕ ПОВЫШЕНОЙ СЛОЖНОСТИ - выполнять по желанию***
  
  Код должен быть защищен от ошибок. Представьте, что классом будет 
  пользоваться другой программист. Если он передает неправильный тип 
  гамбургера, например, или неправильный вид добавки, должно выбрасываться 
  исключение (ошибка не должна молча игнорироваться).
  При неправильном использовании класс сообщает об этом с помощью выброса исключения.
*/
                                    
/**
 * Представляет информацию об ошибке в ходе работы с гамбургером. 
 * Подробности хранятся в свойстве message.
 * @constructor 
 */
function HamburgerException (...) { ... }

// не передали обязательные параметры
const h2 = new Hamburger(); // => HamburgerException: no size given

// передаем некорректные значения, добавку вместо размера
const h3 = new Hamburger(Hamburger.TOPPING_SPICE, Hamburger.TOPPING_SPICE); 
// => HamburgerException: invalid size 'TOPPING_SPICE'

// добавляем много добавок
const h4 = new Hamburger(Hamburger.SIZE_SMALL, Hamburger.STUFFING_CHEESE);
hamburger.addTopping(Hamburger.TOPPING_SAUCE);
hamburger.addTopping(Hamburger.TOPPING_SAUCE); 
// => HamburgerException: duplicate topping 'SAUCE'